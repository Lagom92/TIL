# 6. 하드웨어의 한계

<br/>

컴퓨터는 RAM(랜덤 엑세스 메모리)이라는 물리적 저장장치를 포함하고 있다.

RAM은 유한한 크기의 비트만 저장할 수 있기 때문에 때때로 부정확한 결과를 내기도 한다.



<br/>

### 부동 소수점 부정확성

실수 x, y를 인자로 받아 x 나누기 y를 하는 프로그램

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자에게 x 값 받기
    float x = get_float("x: ");
    
    // 사용자에게 y 값 받기
    float y = get_float("y: ");
    
    // 나눗셉 후 출력하기
    printf("x/y = %.50f\n", x/y);
}
```



<br/>

- x = 1, y = 10일 경우
  - 정확한 결과는 0.1이 되어야 하지만
  - float에서 저장 가능한 비트 수가 유한하기 때문에 다소 부정확한 결과를 내게 된다.
  - x / y =  0.10000000149011611938476562500000000000000000000000



<br/>

### 정수 오버플로우

비슷한 오류로, 1부터 시작하여 2를 계속해서 곱하여 출력하는 아래와 같은 프로그램

```c
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    for (int i = 1;;i*= 2)	// 1부터 2를 영원히 계속 곱해라.
    {
        printf("%i\n", i)
            sleep(1);	// 1초를 쉬는 함수
    }
}
```



<br/>

- 변수 i를 int로 저장하기 때문에, 2를 계속 곱하다가 보면 int 타입이 저장할 수 있는 수를 넘은 이후에는 아래와 같은 에러와 함 께 0이 출력된다.

````
...
536870912
1073741824
overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
-2147483648
0
0
...
````



<br/>

- 정수를 계속 키우는 프로그램에서 10억을 넘어가자 앞으로 넘어갈 1의 자리가 없어진것
- int가 32개의 비트이기 때문
- 실생활에서도 이런 오버플로우 문제가 발생한다.
  - Y2K문제
  - 비행기 보잉 787에서 구동 후 248일이 지나면 모든 전력을 잃는 문제





<br/><br/>